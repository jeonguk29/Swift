import UIKit

/*:
# 앨런 - Swift 마스터 스쿨 17기
*/
/*:
## 네번째 테스트 (5주차)
---
*/
/**>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 그동안 배운 내용의 복습 및 약간의 응용이 들어가 있을 뿐입니다. 이 문제를 잘 풀 수 있다고
 좋은 개발자가 될 수 있는 것도 아니고, 실망하거나 좌절할 필요도 없습니다.
 우린 이제 시작일 뿐입니다. 😄
 가장 중요한 것은 포기하지 않고, 꾸준함을 유지하는 것일뿐!
 안풀리면, 다음 문제로 넘어가면되고, 이번에 못풀면 잘 공부해서, 다음 번에 똑같은 문제를 잘 풀면됩니다.
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>**/

// 서술형의 경우, 주석처리를 하고 작성하면 됩니다.
// (시간이 약간 모자랄 수도 있을 것 같긴한데, 되는 대로 풀어서, 슬랙 DM으로 전달해 주세요!)

// 꼭 정해진 시간 이외에도 풀어보시는대로 전달해 주시면,
// 제가 대략적으로 실력을 파악하는데 도움이 됩니다. (조언도 드릴 수 있고요!)




/**==================================================================
 [1번 문제]
  - 클래스나 구조체에서 initializer(생성자)의 역할이 무엇인가요? 간단하게 서술하세요.
 ===================================================================**/


// 생성자의 역할은 결국,
// 클래스나 구조체의 모든 저장 속성(각각의 데이터 필드라고 보면됨)에
// 초기값을 설정하여 인스턴스를 생성할 수 있도록 하는 것
// (물론 실제 인스턴스를 메모리에 생성하는 과정까지 포함)

// 즉, 저장속성의 메모리에 모든 값들을 갖게 만들어,
// 각각의 인스턴스가 모든 데이터(저장 속성의 모든 항목 - Field)를 가지고
// 데이터로써의 역할을 제대로 할 수 있도록 생성하는 함수라고 보시면 됩니다.






/**==================================================================
 [2번 문제]
  - 아래 Dog클래스의 생성자를 완성해 보세요.
 ===================================================================**/


// 주석을 제거하고 구현하세요.
class Dog {
    var name: String
    var weight: Int

    // 생성자 구현 하기 (파라미터 이름 구현은 자유)
    init(name: String, weight: Int) {
        self.name = name
        self.weight = weight
    }
}






/**==================================================================
 [3번 문제]
  - 클래스와 구조체의 근본적인 메모리 구조의 차이점에 대해서, 간단하게 설명해주세요.
    (힌트. Heap(힙)과 Stack(스택)을 참고적으로)
 ===================================================================**/


// 1) 클래스
// 실제 인스턴스(데이터)는 힙에 저장되고, 그 인스턴스를 가리키는 변수에 메모리 주소가 담겨 스택에 저장됨
// (참조 타입)

// 2) 구조체
// 실제 인스턴스의 데이터 자체가 스택에 저장됨
// (값 타입)






/**==================================================================
 [4번 문제]
  - 클래스나 구조체에서 지연(lazy) 저장 속성은 뭔가요? 왜 필요할까요? 간단하게 서술하세요.
 ===================================================================**/

// 저장 속성 중에서, 해당 속성이 반드시 처음부터 초기화가 필요하지 않은 경우
// 초기화를 지연시키려는 목적을 가진 저장 속성

// 해당 지연 저장 속성에 대한 접근을 하는 순간 초기화 됨(메모리 공간 생성)
// lazy var로만 선언 가능하고 (생성자에서 초기화하지 않기 때문에) 반드시 기본값이 필요함

// 일반적으로 불필요한 메모리 공간의 낭비를 막을 수 있고,
// (이미 메모리에 로드 되어있는) 다른 저장 속성을 이용해야할 때 사용가능함






/**==================================================================
 [5번 문제]
  - 아래의 코드를 활용해,
    (1) 타입 저장 속성을 구현해보세요. 문자열 타입 저장 속성을 구현하면 됩니다.
        (힌트. 종을 의미하는 species의 변수를 만들어 "Dog"이라는 문자열을
         저장하려고 합니다.)
    (2) 또한 해당 타입 저장 속성에 접근하는 코드를 구현하세요.
 ===================================================================**/



class Dog2 {
    
    //(여기에) 타입 저장 속성의 구현
    static let species: String = "Dog"
    
    var name: String
    var weight: Double
    
    init(name: String, weight: Double) {
        self.name = name
        self.weight = weight
    }

}


// 그리고 해당 타입 저장 속성에 접근하는 한줄의 코드 구현 (힌트. 타입 속성)

Dog2.species





/**==================================================================
 [6번 문제]
  - 아래의 코드 예제에서, Bclass는 Aclass를 상속하고 있습니다. Bclass의 저장속성인
    z를 고려해서, Bclass의 지정생성자를 한개이상 구현하고, 상위(Aclass)의 지정생성자
    (init(x: Int, y: Int))를 편의생성자로 재정의 해보세요.
    (자유롭게 구현해보세요.)
 ===================================================================**/


class Aclass {
    var x: Int
    var y: Int
    
    init(x: Int, y: Int) {
        self.x = x
        self.y = y
    }
    
    convenience init() {
        self.init(x: 0, y: 0)
    }
}



// 아래의 주석을 제거하고 코드를 구현

class Bclass: Aclass {

    var z: Int

    // 이 부분에 지정생성자 및 편의 생성자(상위의 지정생성자를 재정의해서) 구현
    init(x: Int, y: Int, z: Int) {
        self.z = z              // (현 단계에서) 새로운 저장속성을 추가했기 때문에, 값을 셋팅할 필요 ⭐️
        super.init(x: x, y: y)  // 나머지 x, y 는 상위에서 구현했기 때문에, 실제 메모리 값을 찍어내는 것은 상위지정생성자에서만 가능 ⭐️
    }
    
    convenience override init(x: Int, y: Int) {  // 상위에 있는 생성자와 동일한 이름을 가졌기 때문에 재정의
        self.init(x: x, y: y, z: 0)              // 다만, 편의생성자로 재정의 했기 때문에 (현 단계의) 지정생성자 호출 필요 ⭐️
    }
}





/**==================================================================
 [7번 문제]
  - 아래의 코드를 이용해 Singleton패턴 구현을 위한 코드를 완성해 보세요.
 ===================================================================**/



class Singleton {
    // 아래 주석 제거후, 싱글톤 구현을 위한 속성 완성
    static let shared = Singleton()
    var userInfoId = 12345

    // 생성자 구현 완성
    private init() { }
}


// 싱글톤 인스턴스에 접근
Singleton.shared




/**==================================================================
 [8번 문제]
  - 클래스에서 convenience(편의) 생성자는 어떤 개념인가요? 아는대로 간단하게 서술하세요.
 ===================================================================**/


// 편의 생성자는 말그대로 (일반적으로 지정생성자보다 적은 갯수의 파라미터로)
// "편리하게" 사용하기 위한 생성자

// 즉, 지정생성자가 직접적으로 메모리값을 셋팅하는 역할을 하는 생성자라면,
// 편의 생성자는 직접적으로 메모리값을 셋팅하지 않고,
// 메모리값을 셋팅하는 것을 지정생성자에게 위임하는 생성자

// 따라서, 편의생성자 내부에서 반드시 (나의 단계의)지정생성자를 호출해야함 (self.init(...))



/**==================================================================
 [9번 문제]
  - 아래의 SubClass에서, 상위의 SuperClass의 sayHello 메서드를 재정의해서,
    아래 처럼 출력되도록 구현해 보세요.
 
    "안녕하세요."   // super호출 코드로 구현
    "반갑습니다."
    "잘 부탁드려요."
 ===================================================================**/


class SuperClass {
    func sayHello() {
        print("안녕하세요.")
    }
}



class SubClass: SuperClass {
    // 메서드 재정의 코드 구현
    override func sayHello() {
        super.sayHello()
        print("반갑습니다.")
        print("잘 부탁드려요.")
    }
}


// 코드 실행
var subClass = SubClass()
subClass.sayHello()


// 원하는 출력
// "안녕하세요."
// "반갑습니다."
// "잘 부탁드려요."





/**==================================================================
 [10번 문제]
  - 아래의 코드는 앱을 만들 때 쓰이는 뷰컨트롤러 코드입니다. 내부에서, 버튼이 눌리면
    버튼의 제목이 바뀌는 코드를 구현하려고합니다. (그리고 아래의 코드는 스토리 보드와
    연결되어 있다고 가정합니다. 실제는 아니더라도)
  - 현재는 버튼의 제목이 "누르세요"라고 되어있다고 가정하고, 버튼을 실제 누르면
    버튼의 제목이 "눌렀음"으로 변경되도록 구현하려는 상황을 가정하는 예시입니다.
  - 아래, 버튼의 제목이 바뀌는 코드를 구현하세요.
    (참고. 타입 캐스팅의 예시 상황 이해를 위한 코드)
    (힌트. button의 타이틀(제목)을 바꿀 수 있는 메서드가 뭐였죠?)
 ===================================================================**/


class ViewController {
    
    @IBAction func buttonDidTapped(sender: Any) {
        let button = sender as! UIButton
        
        // 버튼의 타이틀(제목)을 바꾸는 코드를 작성 ==> 버튼은 "눌렸음"라는 타이틀로 변경하려함
        button.setTitle("눌렸음", for: .normal)
    }
    
}


// 포인트 ⭐️
// 일반적으로 수업에서 sender 파라미터의 타입을 UIButton타입으로 구현했지만
// 여기서는 Any타입으로 구현했을때, 어떤 불편함이 있는지 알려드리기 위함

// Any ==> UIButton 타입으로 다운캐스팅 (sender가 실제 버튼 타입이기 때문에 다운캐스팅이 가능한 것)
// 다운캐스팅해서, UIButton타입으로 변형을 해야지만 setTitle이라는 메서드에 접근 가능해짐




/**==================================================================
 [11번 문제]
  - 아래의 코드는 부모클래스를 상속하는, 상속관계의 코드입니다. 현재 Undergraduate
    인스턴스가 Person타입으로 person1 상수에 담겨있는데,
    해당 인스턴스가 가진 저장 속성 중에 하나인 "전공"을 출력하려고 합니다.
    print(person1.major)
    전공을 출력하기 위해, 필요한 코드를 중간에 삽입하세요.
    (힌트. 타입 캐스팅)
 ===================================================================**/


class Person {
    var id = 0
}

class Student: Person {
    var studentId = 1
}

class Undergraduate: Student {
    var major = "전공"
}



let person1: Person = Undergraduate()

// 아래 "전공"을 출력하기 위해서, 중간에 코드를 삽입하세요.
// (필요한 경우, 프린트 코드의 person1 상수를 변경해도 됩니다.)

// 첫번째 방법)  다운캐스팅 ==> 옵셔널 바인딩까지

if let person2 = person1 as? Undergraduate {
    print(person2.major)    // "전공" 출력을 원함
}


// 두번째 방법)  (강제) 다운캐스팅

let person2 = person1 as! Undergraduate
print(person2.major)    // "전공" 출력을 원함



/**==================================================================
 [12번 문제]
  - 클래스와 구조체, 열거형에서 확장(Extension)의 개념이 뭘까요? 간단하게 서술하세요.
 ===================================================================**/


// 확장(Extension)
// 상속과 비교해서 수평확장의 개념으로, 이미 존재하는 타입에, 기능(메서드)을 추가하여 사용하려는 것
// 메서드를 추가하는 것만 가능 (저장속성은 추가 불가)

// 확장에서 유의할 것 한가지는 클래스에서 생성자를 구현하려는 경우, 편의생성자 형태만 추가 가능
// (클래스는 상속과 관련이 있으므로, 지정생성자는 실제 저장속성의 메모리값 셋팅과 관련이 있기 때문에
//  확장에서 가능하게 만든다면.. 상속관계에서, (하위 지정생성자에서) 상위 지정생성자 호출 관계 등
//  이 잘못될 수 있기 때문에 막고 있음)





/**==================================================================
 [13번 문제]
  - 프로토콜(Protocol)의 개념이 뭘까요? 간단하게 서술하세요.
 ===================================================================**/


// 프로토콜 (Protocol)
// 클래스의 상속의 단점을 보완해서, 자격증의 개념으로 어떤 클래스, 구조체, 열거형에서도
// 채택해서 최소한의 요구사항만을 구현하면 해당 자격증의 기능을 사용할 수 있음
// 자격증 자체가 타입의 역할도 가능하므로, 실제 앱구현에서 많이 쓰임

// 프로토콜의 확장에서는 해당 프로토콜을 채택했을때의 기본구현의 제공도 가능 함






/**==================================================================
 [14번 문제]
  - 아래의 RemoteControl 프로토콜을 채택한 SmartPhone 클래스의 구현을 완성하세요.
    (조건)
    (1) name 속성은 계산 속성으로 구현하세요.
        get블록 - "아이폰"을 리턴하도록 구현
        set블록 - 내부 구현은 안해도 됨
    (2) turnOff 메서드는
        "꺼졌습니다."를 출력하도록 구현
 ===================================================================**/

// RemoteControl 프로토콜
protocol RemoteControl {
    var name: String { get }
    func turnOff()
}


// RemoteControl 프로토콜을 채택한 SmarPhone클래스
class SmartPhone: RemoteControl {
    // 내부 구현
    var name: String {
        get {
            return "아이폰"
        }
        set {
            
        }
    }
    
    func turnOff() {
        print("꺼졌습니다.")
    }
}






/**==================================================================
 [15번 문제]
  - 아래에서는 함수를 정의(1)하고, 해당 함수를 실행(2)하는 코드입니다. 아래의 (2)코드를
    간단한 형태 클로저로 변형하세요. 아는 한에서 가장 간단한 형태로 변형한 클로저를
    작성하시면 됩니다.
 ===================================================================**/


// (1) (콜백함수를 사용한)함수를 정의

func performClosure(param: (String) -> Int) {
    param("Swift")
}

// (2) 변형하고자 하는 클로저의 형태 (변형 전) - 위에서 정의된 함수를 실행 / 실행하면서, 클로저(함수)를 사용

performClosure(param: { (str: String) in
    return str.count
})


// (변형하고자 하는 코드) 가장 간단한 형태의 클로저로 변형된 코드를 작성

performClosure { $0.count }






/**>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 수고 하셨습니다. 😄
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>**/
