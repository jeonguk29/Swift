import UIKit

/*:
# 앨런 - Swift 마스터 스쿨 17기
*/
/*:
## 네번째 테스트 (5주차)
---
*/
/**>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 그동안 배운 내용의 복습 및 약간의 응용이 들어가 있을 뿐입니다. 이 문제를 잘 풀 수 있다고
 좋은 개발자가 될 수 있는 것도 아니고, 실망하거나 좌절할 필요도 없습니다.
 우린 이제 시작일 뿐입니다. 😄
 가장 중요한 것은 포기하지 않고, 꾸준함을 유지하는 것일뿐!
 안풀리면, 다음 문제로 넘어가면되고, 이번에 못풀면 잘 공부해서, 다음 번에 똑같은 문제를 잘 풀면됩니다.
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>**/

// 서술형의 경우, 주석처리를 하고 작성하면 됩니다.
// (시간이 약간 모자랄 수도 있을 것 같긴한데, 되는 대로 풀어서, 슬랙 DM으로 전달해 주세요!)

// 꼭 정해진 시간 이외에도 풀어보시는대로 전달해 주시면,
// 제가 대략적으로 실력을 파악하는데 도움이 됩니다. (조언도 드릴 수 있고요!)



/**==================================================================
 [1번 문제]
  - 클래스나 구조체에서 initializer(생성자)의 역할이 무엇인가요? 간단하게 서술하세요.
 ===================================================================**/

// 실질적으로 인스턴스를 찍어내는 즉 메모리에 값을 셋팅하는 역할을 함








/**==================================================================
 [2번 문제]
  - 아래 Dog클래스의 생성자를 완성해 보세요.
 ===================================================================**/


// 주석을 제거하고 구현하세요.
class Dog {
    var name: String
    var weight: Int

    // 생성자 구현 하기 (파라미터 이름 구현은 자유)
    init(name:String, weight:Int){
        self.name = name
        self.weight = weight
    }

}

var dogi = Dog(name: "예삐", weight: 20)
print(dogi.name,dogi.weight)



/**==================================================================
 [3번 문제]
  - 클래스와 구조체의 근본적인 메모리 구조의 차이점에 대해서, 간단하게 설명해주세요.
    (힌트. Heap(힙)과 Stack(스택)을 참고적으로)
 ===================================================================**/

/*
 클래스와 구조체는 둘다 데이터영역에 저장한다는 공통점이 있고
 클래스로 인스턴스 즉 객체를 찍을때는 힙영역에 생성함
 클래스에 인스턴스는 힙영역에서 저장 속성에 대한 값을 저장하고 있으며
 메서드 같은경우에는 공통적으로 사용하는 영역이라 데이터영역에 메서드 테이블을 이용
 클래스의 인스턴스를 저장하는 변수의 경우 메모리 주소값을 저장
 *ARC와 같은 메모리 관리 기법으로 인스턴스 메모리를 관리한다는 특징이 있음 인스턴스를 담은 변수가
 사라져도 힙영역에는 남아 있을 수도 있기 때문
 
 
 구조체로 인스턴스를 찍을때는 스택영역에 생성하고 클래스와 다르게 해당 인스턴스를 담는 변수안에
 저장속성에 관한 값을 직접 찍어서 생성함 메서드 같은 경우에는  Direct Dispatch로 직접 코드영역에 있는
 메모리 주소로 이동하기 때문에 내부적 속도를 비교하면 구조체가 더 빠름 인스턴스 생성시에도 클래스는
 힙영역에 빈공간을 찾기 때문에 좀더 느림
 해당 인스턴스를 담고있는 변수에 스택영역이 사라지면 해당 값들도 모두 사라짐
 
 */












/**==================================================================
 [4번 문제]
  - 클래스나 구조체에서 지연(lazy) 저장 속성은 뭔가요? 왜 필요할까요? 간단하게 서술하세요.
 ===================================================================**/

// 지연저장 속성은 인스턴스를 생성할때 바로 메모리에 찍어내는게 아닌 처음 호출시 메모리에 찍는 저장 속성임
// 메모리 공간을 절약한다는 특징이 있고 생성자를 통해서 값을 설정하는게 아니라 초기값과 lazy var로만 선언 가능함









/**==================================================================
 [5번 문제]
  - 아래의 코드를 활용해,
    (1) 타입 저장 속성을 구현해보세요. 문자열 타입 저장 속성을 구현하면 됩니다.
        (힌트. 종을 의미하는 species의 변수를 만들어 "Dog"이라는 문자열을
         저장하려고 합니다.)
    (2) 또한 해당 타입 저장 속성에 접근하는 코드를 구현하세요.
 ===================================================================**/



class Dog2 {
    
    //(여기에) 타입 저장 속성의 구현
    
    static var species = "Dog"
    
    var name: String
    var weight: Double
    
    init(name: String, weight: Double) {
        self.name = name
        self.weight = weight
    }

}


// 그리고 해당 타입 저장 속성에 접근하는 한줄의 코드 구현 (힌트. 타입 속성)


Dog2.species

/*
 static으로 타입 저장 속성을 만들경우 상속 불가
 class로 타입 저장 속성을 만들경우 상속 가능
 */





/**==================================================================
 [6번 문제]
  - 아래의 코드 예제에서, Bclass는 Aclass를 상속하고 있습니다. Bclass의 저장속성인
    z를 고려해서, Bclass의 지정생성자를 한개이상 구현하고, 상위(Aclass)의 지정생성자
    (init(x: Int, y: Int))를 편의생성자로 재정의 해보세요.
    (자유롭게 구현해보세요.)
 ===================================================================**/


class Aclass {
    var x: Int
    var y: Int
    
    init(x: Int, y: Int) {
        self.x = x
        self.y = y
    }
    
    convenience init() {
        self.init(x: 0, y: 0)
    }
}



// 아래의 주석을 제거하고 코드를 구현

class Bclass: Aclass {

    var z: Int

    // 이 부분에 지정생성자 및 편의 생성자(상위의 지정생성자를 재정의해서) 구현

    init(x: Int, y: Int, z:Int) {
        self.z = z
        super.init(x: x, y: y)
    }
    
    convenience override init(x: Int, y: Int) {
        self.init(x: x, y: y, z:0)
    }
    

}





/**==================================================================
 [7번 문제]
  - 아래의 코드를 이용해 Singleton패턴 구현을 위한 코드를 완성해 보세요.
 ===================================================================**/



class Singleton {
    // 아래 주석 제거후, 싱글톤 구현을 위한 속성 완성
    let shared = Singleton()
    var userInfoId = 12345

    // 생성자 구현 완성
    private init(){
    }
}







/**==================================================================
 [8번 문제]
  - 클래스에서 convenience(편의) 생성자는 어떤 개념인가요? 아는대로 간단하게 서술하세요.
 ===================================================================**/


// 개념설명 그대로 좀더 편하게 생성자를 이용하기 위한 개념이며
// 델리게이트 어크로스 개념이 있기 때문에 결론적으로는 지정 생성자를 호출 해야한다는 원칙이 있음
// 상속이 되지 않는다는 특징이 있는데 예외적으로 모든 상위 클래스의 저장속성이 초기화 되어있는 경우
// 혹은 모든 지정생성자를 재정의 한경우 자동 상속이 가능함










/**==================================================================
 [9번 문제]
  - 아래의 SubClass에서, 상위의 SuperClass의 sayHello 메서드를 재정의해서,
    아래 처럼 출력되도록 구현해 보세요.
 
    "안녕하세요."   // super호출 코드로 구현
    "반갑습니다."
    "잘 부탁드려요."
 ===================================================================**/


class SuperClass {
    func sayHello() {
        print("안녕하세요.")
    }
}



class SubClass: SuperClass {
    // 메서드 재정의 코드 구현
    override func sayHello() {
        super.sayHello()
        print("반갑습니다.")
        print("잘 부탁드려요.")
    }
    
}


// 코드 실행
var subClass = SubClass()
subClass.sayHello()


// 원하는 출력
// "안녕하세요."
// "반갑습니다."
// "잘 부탁드려요."





/**==================================================================
 [10번 문제]
  - 아래의 코드는 앱을 만들 때 쓰이는 뷰컨트롤러 코드입니다. 내부에서, 버튼이 눌리면
    버튼의 제목이 바뀌는 코드를 구현하려고합니다. (그리고 아래의 코드는 스토리 보드와
    연결되어 있다고 가정합니다. 실제는 아니더라도)
  - 현재는 버튼의 제목이 "누르세요"라고 되어있다고 가정하고, 버튼을 실제 누르면
    버튼의 제목이 "눌렀음"으로 변경되도록 구현하려는 상황을 가정하는 예시입니다.
  - 아래, 버튼의 제목이 바뀌는 코드를 구현하세요.
    (참고. 타입 캐스팅의 예시 상황 이해를 위한 코드)
    (힌트. button의 타이틀(제목)을 바꿀 수 있는 메서드가 뭐였죠?)
 ===================================================================**/


class ViewController {
    
    @IBAction func buttonDidTapped(sender: Any) {
        let button = sender as! UIButton
        
        // 버튼의 타이틀(제목)을 바꾸는 코드를 작성 ==> 버튼은 "눌렸음"라는 타이틀로 변경하려함
        //button.setTitle("눌렸음", for: UIControl.State)
    }
    
}


/*
 엘런 답
 
 class ViewController {
     
     @IBAction func buttonDidTapped(sender: Any) {
         let button = sender as! UIButton
         
         // 버튼의 타이틀(제목)을 바꾸는 코드를 작성 ==> 버튼은 "눌렸음"라는 타이틀로 변경하려함
         button.setTitle("눌렸음", for: .normal)
     }
     
 }


 // 포인트 ⭐️
 // 일반적으로 수업에서 sender 파라미터의 타입을 UIButton타입으로 구현했지만
 // 여기서는 Any타입으로 구현했을때, 어떤 불편함이 있는지 알려드리기 위함

 // Any ==> UIButton 타입으로 다운캐스팅 (sender가 실제 버튼 타입이기 때문에 다운캐스팅이 가능한 것)
 // 다운캐스팅해서, UIButton타입으로 변형을 해야지만 setTitle이라는 메서드에 접근 가능해짐


 */



/**==================================================================
 [11번 문제]
  - 아래의 코드는 부모클래스를 상속하는, 상속관계의 코드입니다. 현재 Undergraduate
    인스턴스가 Person타입으로 person1 상수에 담겨있는데,
    해당 인스턴스가 가진 저장 속성 중에 하나인 "전공"을 출력하려고 합니다.
    print(person1.major)
    전공을 출력하기 위해, 필요한 코드를 중간에 삽입하세요.
    (힌트. 타입 캐스팅)
 ===================================================================**/


class Person {
    var id = 0
}

class Student: Person {
    var studentId = 1
}

class Undergraduate: Student {
    var major = "전공"
}



let person1: Person = Undergraduate()

// 아래 "전공"을 출력하기 위해서, 중간에 코드를 삽입하세요.
// (필요한 경우, 프린트 코드의 person1 상수를 변경해도 됩니다.)


let person2 : Undergraduate = person1 as! Undergraduate
print(person2.major)    // "전공" 출력을 원함


if let person1 = person1 as? Undergraduate {   // if let 바인딩과 함께 사용 (옵셔널 언래핑)
    print(person1.major)
}

/**==================================================================
 [12번 문제]
  - 클래스와 구조체, 열거형에서 확장(Extension)의 개념이 뭘까요? 간단하게 서술하세요.
 ===================================================================**/



// 확장(Extension)
// 상속과 비교해서 수평확장의 개념으로, 이미 존재하는 타입에, 기능(메서드)을 추가하여 사용하려는 것
// 메서드를 추가하는 것만 가능 (저장속성은 추가 불가)

// 확장에서 유의할 것 한가지는 클래스에서 생성자를 구현하려는 경우, 편의생성자 형태만 추가 가능
// (클래스는 상속과 관련이 있으므로, 지정생성자는 실제 저장속성의 메모리값 셋팅과 관련이 있기 때문에
//  확장에서 가능하게 만든다면.. 상속관계에서, (하위 지정생성자에서) 상위 지정생성자 호출 관계 등
//  이 잘못될 수 있기 때문에 막고 있음)


// 구조체인 경우 저장속성을 수정하는 메서드를 구현시 뮤터블 키워드를 붙여줘야함









/**==================================================================
 [13번 문제]
  - 프로토콜(Protocol)의 개념이 뭘까요? 간단하게 서술하세요.
 ===================================================================**/


/* 프로토콜은 자격증과 같은개념이며
 기존에 클래스의 상속의 단점을 보완할수 있는 장점이 있음 ex 클래스의 상속은 원하지 않은 기능까지 상속 : 상위클래스의 메모리 구조를 따라감
 , 다중 상속이 불가능 했지만 프로토콜은 다중 상속이 가능함, 클래스만 사용이 가능 했지만  구조체 및 값타입에서도 사용 할 수 있음
 프로토콜을 채택한다면 그 자격증에 맞는 요구조건을 구현해줘야함

*/








/**==================================================================
 [14번 문제]
  - 아래의 RemoteControl 프로토콜을 채택한 SmartPhone 클래스의 구현을 완성하세요.
    (조건)
    (1) name 속성은 계산 속성으로 구현하세요.
        get블록 - "아이폰"을 리턴하도록 구현
        set블록 - 내부 구현은 안해도 됨
    (2) turnOff 메서드는
        "꺼졌습니다."를 출력하도록 구현
 ===================================================================**/

// RemoteControl 프로토콜
protocol RemoteControl {
    var name: String { get }
    func turnOff()
}


// RemoteControl 프로토콜을 채택한 SmarPhone클래스
class SmartPhone: RemoteControl {
    var name: String {
        get {
            "아이폰"
        }
    
    }
    
    func turnOff() {
        print("꺼졌습니다.")
    }
    

}

var test = SmartPhone()
print(test.name)
test.turnOff()




/**==================================================================
 [15번 문제]
  - 아래에서는 함수를 정의(1)하고, 해당 함수를 실행(2)하는 코드입니다. 아래의 (2)코드를
    간단한 형태 클로저로 변형하세요. 아는 한에서 가장 간단한 형태로 변형한 클로저를
    작성하시면 됩니다.
 ===================================================================**/


// (1) (콜백함수를 사용한)함수를 정의

func performClosure(param: (String) -> Int) {
    param("Swift")
}

// (2) 변형하고자 하는 클로저의 형태 (변형 전) - 위에서 정의된 함수를 실행 / 실행하면서, 클로저(함수)를 사용

performClosure(param: { (str: String) in
    return str.count
})


// (변형하고자 하는 코드) 가장 간단한 형태의 클로저로 변형된 코드를 작성

performClosure(){ str in
    str.count
}








/**>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 수고 하셨습니다. 😄
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>**/
