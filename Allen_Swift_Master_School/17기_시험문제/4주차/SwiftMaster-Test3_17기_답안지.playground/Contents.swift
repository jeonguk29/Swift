import UIKit

/*:
# 앨런 - Swift 마스터 스쿨 17기
*/
/*:
## 세번째 테스트 (4주차) 답안지
---
*/
/**>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 그동안 배운 내용의 복습 및 약간의 응용이 들어가 있을 뿐입니다. 이 문제를 잘 풀 수 있다고
 좋은 개발자가 될 수 있는 것도 아니고, 실망하거나 좌절할 필요도 없습니다.
 우린 이제 시작일 뿐입니다. 😄
 가장 중요한 것은 포기하지 않고, 꾸준함을 유지하는 것일뿐!
 안풀리면, 다음 문제로 넘어가면되고, 이번에 못풀면 잘 공부해서, 다음 번에 똑같은 문제를 잘 풀면됩니다.
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>**/

// 서술형의 경우, 주석처리를 하고 작성하면 됩니다.
// (시간이 약간 모자랄 수도 있을 것 같긴한데, 되는 대로 풀어서, 슬랙 DM으로 전달해 주세요!)

// 꼭 정해진 시간 이외에도 풀어보시는대로 전달해 주시면,
// 제가 대략적으로 실력을 파악하는데 도움이 됩니다. (조언도 드릴 수 있고요!)




/**==================================================================
 [1번 문제]
  - 함수 만들어 보기: 정수값을 한개 받아, 해당 정수가 짝수인지 여부를 판단하는 함수를
                  구현해 보세요. (힌트: 짝수 -> 참 / 홀수 -> 거짓)
 
    (함수 실행 예시)
    isEvenNumber(num: 3)    // 거짓
    isEvenNumber(num: 4)    // 참
 ===================================================================**/

// 함수 정의 (구현)

func isEvenNumber(num: Int) -> Bool {
    return num % 2 == 0
}




// 함수 실행 (아래 주석 제거하고 실행해보기)

print("1번문제 결과 (1):", isEvenNumber(num: 3))
print("1번문제 결과 (2):", isEvenNumber(num: 4))





/**==================================================================
 [2번 문제]
  - Array(배열), Dictionary(딕셔너리), Set(집합)의 각각의 중요 특징과 차이점에 대해
    서술하고 간단한 예시 코드를 작성해 보세요.
 ===================================================================**/

// 1) 배열(Array)
// 동일한 타입의 요소를 담을 수 있는 컬렉션
// 인덱스 순서가 자동으로 지정되며, 인덱스는 0부터 시작

let array = [1, 2, 3, 4, 5]



// 2) 딕셔너리(Dictionary)
// 키와 밸류의 쌍을 요소로 담을 수 있는 컬렉션
// 순서가 없고, 키(key)값은 유일해야하며, 동일한 타입의 쌍만 담을 수 있음
// 키(key)값은 해셔블(Hashable)해야함

let dic = ["A": "Apple", "B": "Banana"]



// 3) 집합(Set)
// 동일한 타입의 요소를 담을 수 있는, 순서가 없는 컬렉션
// 순서가 없고, 각 요소가 해셔블(Hashable)해야함

let set: Set = [1, 2, 3, 4, 5]



// 공통점
// 1) 동일한 타입 또는 동일한 타입의 쌍을 담을 수 있음
// 2) 위의 모든 컬렉션은 값타입으로 메모리의 스택에 저장

// 차이점
// 1) 배열은 순서가 있고, 딕셔너리와 집합(Set)은 순서가 없음
// 2) 딕셔너리에서는 키(key)값이 해셔블해야하고, 집합(Set)에서는 요소가 해셔블 해야함







/**==================================================================
 [3번 문제]
  - 아래의 personName변수에 들어있는 값을 if let 바인딩으로 언래핑해서 이름을
    출력해 보세요.
 ===================================================================**/

class Person {
    var name: String? = "홍길동"
}

var personName = Person().name


// 옵셔널 바인딩 코드 작성

if let name = personName {
    print(name)
}


// 위와 같이 해도 되고, 이름만 출력해보는 것이 목적이라면,
// personName이라는 변수를 거치지 않고 직접 생성하자마자 옵셔널 바인딩을 하는
// 아래와 같은 방법도 가능


if let name = Person().name {
    print(name)
}







/**==================================================================
 [4번 문제]
  - 아래의 a상수의 옵셔널 값을 switch문으로 이용해서 꺼내서 출력해 보세요.
    (힌트. some과, none 그리고, 연관값을 꺼내는 방법을 이용해 보세요.)
 ===================================================================**/


let a: Int? = 7


// (주석 해제하고) 나머지 전부 구현

switch a {
case .some(let num):
    print(num)
case .none:
    //print("nil 입니다.")
    break
}



// ⭐️ 포인트
// 옵셔널은 일단 열거형이죠?
// 따라서, 열거형의 케이스인 .some / .none으로 먼저 분기처리하고
// 내부의 값을 let num 으로 바인딩해서 꺼낼 수가 있습니다. (열거형 케이스 패턴)





/**==================================================================
 [5번 문제]
  - 클래스나 구조체에서 initializer(생성자)의 역할이 무엇인가요? 간단하게 서술하세요.
 ===================================================================**/

// 생성자의 역할은 결국,
// 클래스나 구조체의 모든 저장 속성(각각의 데이터 필드라고 보면됨)에
// 초기값을 설정하여 인스턴스를 생성할 수 있도록 하는 것이죠.
// (물론 실제 인스턴스를 메모리에 생성하는 과정까지 포함)

// 즉, 저장속성의 메모리에 모든 값들을 갖게 만들어,
// 각각의 인스턴스가 모든 데이터(저장 속성의 모든 항목 - Field)를 가지고
// 데이터로써의 역할을 제대로 할 수 있도록 만들어 주는 함수라고 보시면 됩니다.







/**==================================================================
 [6번 문제]
  - 구조체의 멤버와이즈 이니셜라이저(생성자)가 무엇인가요? 개념에 대해 간단하게
    서술하고, (자유롭게) 예제 코드를 만들어 설명해주세요.
    (힌트. Memberwise (멤버에 관한))
 ===================================================================**/


// 구조체의 경우,
// 생성자를 직접적으로 구현하지 않더라도, 모든 저장속성 값을 초기화할 수 있는 생성자를 자동으로
// 구현, 제공해줌 - (멤버와이즈 이니셜라이저)


struct Dog {
    var name: String
    var weight: Double
}

//Dog(name: <#T##String#>, weight: <#T##Double#>)



// 멤버와이즈 이니셜라이저로 인해, 구조체 사용시 (생성자의 직접 구현 없이)
// 보다 간편하게 사용 가능







/**==================================================================
 [7번 문제]
  - 클래스와 구조체의 근본적인 메모리 구조의 차이점에 대해서, 간단하게 설명해주세요.
    (힌트. Heap(힙)과 Stack(스택)을 참고적으로)
 ===================================================================**/


// 1) 클래스
// 실제 인스턴스(데이터)는 힙에 저장되고, 그 인스턴스를 가리키는 변수에 메모리 주소가 담겨 스택에 저장됨
// (참조 타입)

// 2) 구조체
// 실제 인스턴스의 데이터 자체가 스택에 저장됨
// (값 타입)






/**==================================================================
 [8번 문제]
  - 클래스(또는 구조체)에서 계산 속성의 의미가 뭔가요?
  - 아래의 Person2 구조체에서 bmi라는 계산 속성을 구현해서, 쉽게 사람의 BMI를 계산하고
    값을 얻을 수 있게 구현해 보세요.
    (읽기/ 쓰기 속성을 모두 구현해 보세요)
 
    BMI지수 = 몸무게 / 키 x 키         (몸무게를 키의 제곱으로 나눈 값이 BMI)
            (kg기준) (키는 미터 기준)
 
 ===================================================================**/

struct Person2 {
    var name: String = "사람"
    var height: Double = 160.0
    var weight: Double = 60.0
    
    //bmi 계산 속성 구현해서 완성
    var bmi: Double {
        get {
            let bmi = weight / (height * height) * 10000
            return bmi
        }
        set {
            weight = newValue * height * height / 10000
        }
    }
    
}



// (계산 속성에 대한) 간단한 서술
// (계산속성의 의미, 역할, 필요한 이유 등을 간단하게)

// 계산 속성은 실질적인 메서드(함수)임 ⭐️
// 단지, 외부에서 겉모습을 속성처럼 보이게 해서, 코드를 직관적으로 사용할 수 있는 것 뿐임
// 따라서, 어떤 속성에 대해
// 읽기 메서드 / 쓰기 메서드를 구현하는 것에 불과함
// (두개의 함수/메서드를 구현한다고 생각하고 접근하면 쉽게 구현 가능)






/**==================================================================
 [9번 문제]
  - 클래스(또는 구조체)에서 속성 감시자의 의미가 뭔가요?
  - 아래의 Profile 클래스에서 message의 변수(속성)에 didSet 속성감시자를 구현해보세요.
    (didSet에서 아래의 메세지를 출력해 보세요.)
 
    print("메세지 - \(여기에뭘써야하죠)에서 \(message)로 변경됨")
 
    위의 문장을 복사해서 사용하세요.
 ===================================================================**/


class Profile {
    var message: String = "기본메세지" {   // 속성 감시자 구현
        didSet {
            print("메세지 - \(oldValue)에서 \(message)로 변경됨")
        }
    }
}



var p1 = Profile()

p1.message
p1.message = "행복하다"
p1.message



// 속성감시자는 "특정" 저장 속성에 딸려있는 메서드에 불과함 ⭐️
// 저장 속성의 값이 변했을때, 항상 자동으로 호출되는 메서드 !
// 따라서, 당연히 구현방식은 메서드와 동일합니다. 다만, 형태에는 조금 익숙해질 필요가 있죠!





/**==================================================================
 [10번 문제]
  - 값타입(Value Type)과 참조타입(Reference Type)에 대해 아는대로 서술하고
    차이점에 대해서 설명해 보세요.
 ===================================================================**/


// 1) 값타입(Value Type)
// 필요시에 항상 메모리의 값이 복사되어 전달되고, 기본적으로 스택에 저장
// 스택의 스코프가 종료가 되면, 데이터(값)이 메모리에서 자동 제거
// 대부분의 모든 타입은 스택의 메모리에 저장 - 스위프트의 기본타입 / 구조체, 열거형, 컬렉션 등



// 2) 참조타입(Reference Type)
// 필요시에 항상 메모리의 주소를 전달, 변수/상수는 스택에 저장되어 그 안에 힙의 메모리 주소가 저장 (실제 데이터는 힙에 저장)
// ARC를 통해, 메모리 관리가 필요한 데이터
// 클래스와 클로저가 해당







/**==================================================================
 [11번 문제]
  - 객체지향 프로그래밍(OOP)의 4대 특징에 대해 나열하고, 간단하게 서술하세요.
 ===================================================================**/


// (1) 추상화
// 실체들에서, 공통적인 특성을 뽑아내서 만드는 모델링의 개념

// (2) 캡슐화
// 연관이 있는 속성과 메서드를 하나의 클래스로 묶어서 활용한다는 개념

// (3) 상속성
// 부모클래스의 속성과 메서드를 자식클래스에서 물려받아, 재활용하는 개념

// (4) 다형성
// 하나의 객체는 다양한 방식(타입)으로 동작가능함을 의미

// (구체적인 내용은 주교재 참조)







/**==================================================================
 [12번 문제]
  - 아래의 코드 예제에서, Bclass는 Aclass를 상속하고 있습니다. Bclass의 저장속성인
    z를 고려해서, Bclass의 지정생성자를 한개이상 구현하고, 상위(Aclass)의 지정생성자
    (init(x: Int, y: Int))를 편의생성자로 재정의 해보세요.
    (자유롭게 구현해보세요.)
 ===================================================================**/


class Aclass {
    var x: Int
    var y: Int
    
    init(x: Int, y: Int) {
        self.x = x
        self.y = y
    }
    
    convenience init() {
        self.init(x: 0, y: 0)
    }
}



// 아래의 주석을 제거하고 코드를 구현

class Bclass: Aclass {

    var z: Int

    // 이 부분에 지정생성자 및 편의 생성자(상위의 지정생성자를 재정의해서) 구현

    init(x: Int, y: Int, z: Int) {
        self.z = z
        super.init(x: x, y: y)
    }
    
    convenience override init(x: Int, y: Int) {
        self.init(x: x, y: y, z: 0)
    }
    
    // init()   ====> 상위의 모든 지정생성자를 재정의 해서 구현했기 때문에 편의생성자 자동상속

}




/**==================================================================
 [13번 문제]
  - Singleton패턴이 무엇인가요? 아는 대로 간단하게 서술하고, (자유롭게) 간단한 예제 코드를
    작성해 보세요.
 ===================================================================**/



// 앱을 실행하는 동안, 유일하게 1개만 필요한 인스턴스(객체)의 데이터의 경우, 사용하는 패턴
// 실제 메모리의 하나의 인스턴스만 저장되고, 이것을 공유해서 사용


class Singleton {
    static let shared = Singleton()
    var num = 0
    private init() { }
}


Singleton.shared








/**==================================================================
 [14번 문제]
  - 클래스의 타입 메서드의 구현에서, static 키워드와 class 키워드의 차이는 뭔가요?
    간단하게 서술하세요.
 ===================================================================**/


// "타입" 메서드로 구현하면, 기본적으로 static(고정) 키워드를 붙여야 하죠?
// static - 상속해서 재정의 불가
// class - 상속해서 재정의 가능

// ⭐️ "상속불가"의 개념이 아니고, 상속은 당연히 가능하되 "재정의 불가"의 개념이라는 것 헷갈리시면 안돼요!








/**==================================================================
 [15번 문제]
  - mutating키워드가 뭔가요? 언제 사용했었죠? mutating키워드에 대해서 아는 대로
    간단하게 서술해 보세요.
 ===================================================================**/


// 값타입(구조체, 열거형)에서, 메서드를 정의할때,
// 메서드에서 자신의 저장 속성을 변경할 수 없는 것이 원칙이지만,
// mutating키워드를 붙여서, 변경가능 하도록 "표기"해줄 수 있음







/**==================================================================
 [16번 문제]
  - 아래에서, SomeSuperclass를 상속한 SomeSubclass에서.. 상위 클래스의
    aValue속성을 계산속성으로 자유롭게 재정의 해보세요.
    (계산 속성으로 재정의시 내부 구현은 자유입니다.)
 ===================================================================**/


class SomeSuperclass {
    var aValue = 0
}



class SomeSubclass: SomeSuperclass {

    // 계산속성으로 재정의 구현
    override var aValue: Int {
        get {
            return super.aValue * 2
        }
        set {
            super.aValue = newValue / 2
        }
    }

}



// ⭐️ 포인트
// 원칙적으로 저장 속성을 재정의 하는 것은 불가능하지만,
// 저장속성을 하위의 클래스에서 "계산속성"으로 재정의 하는 것은 가능합니다.

// 저장속성은 고유의 메모리 영역을 차지하는 속성이고 (그래서 재정의 불가하고 - 상위에서 "데이터" 메모리 구조 확정)
// 하위의 클래스에서 계산속성으로 재정의 한다는 것은
// 단순하게, 하위의 클래스에서 메서드를 추가하는 개념일 뿐이기 때문에
// 재정의가 가능해지는 것이예요.







/**>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 수고 하셨습니다. 😄
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>**/
