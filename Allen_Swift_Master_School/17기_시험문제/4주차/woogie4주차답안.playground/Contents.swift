import UIKit

/*:
# 앨런 - Swift 마스터 스쿨 17기
*/
/*:
## 세번째 테스트 (4주차)
---
*/
/**>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 그동안 배운 내용의 복습 및 약간의 응용이 들어가 있을 뿐입니다. 이 문제를 잘 풀 수 있다고
 좋은 개발자가 될 수 있는 것도 아니고, 실망하거나 좌절할 필요도 없습니다.
 우린 이제 시작일 뿐입니다. 😄
 가장 중요한 것은 포기하지 않고, 꾸준함을 유지하는 것일뿐!
 안풀리면, 다음 문제로 넘어가면되고, 이번에 못풀면 잘 공부해서, 다음 번에 똑같은 문제를 잘 풀면됩니다.
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>**/

// 서술형의 경우, 주석처리를 하고 작성하면 됩니다.
// (시간이 약간 모자랄 수도 있을 것 같긴한데, 되는 대로 풀어서, 슬랙 DM으로 전달해 주세요!)

// 꼭 정해진 시간 이외에도 풀어보시는대로 전달해 주시면,
// 제가 대략적으로 실력을 파악하는데 도움이 됩니다. (조언도 드릴 수 있고요!)




/**==================================================================
 [1번 문제]
  - 함수 만들어 보기: 정수값을 한개 받아, 해당 정수가 짝수인지 여부를 판단하는 함수를
                  구현해 보세요. (힌트: 짝수 -> 참 / 홀수 -> 거짓)
 
    (함수 실행 예시)
    isEvenNumber(num: 3)    // 거짓
    isEvenNumber(num: 4)    // 참
 ===================================================================**/

// 함수 정의 (구현)


func isEvenNumber(num: Int) -> Bool{
    return num % 2 == 0
}




// 함수 실행 (아래 주석 제거하고 실행해보기)

print("1번문제 결과 (1):", isEvenNumber(num: 3))
print("1번문제 결과 (2):", isEvenNumber(num: 4))





/**==================================================================
 [2번 문제]
  - Array(배열), Dictionary(딕셔너리), Set(집합)의 각각의 중요 특징과 차이점에 대해
    서술하고 간단한 예시 코드를 작성해 보세요.
 ===================================================================**/

// 1) 배열(Array)
// 배열은 각 요소 값들을 순서대로 저장한다는 특징이 있음, 선언된 해당 타입에 맞는 요소만 넣을 수 있음
var arr: [Int] = [1,2,3,4,5]
print(arr)



// 2) 딕셔너리(Dictionary)
// 딕셔너리는 키와 값을 쌍으로 묶어 저장하는 타입임 해당 키는 해시어블해야 한다는 특징이 있음, 값의 순서가 없으며, 키를 중복값 즉 동일한 이름의 값으로 저장 할 수 없음
var dic: [String:Int] = ["a" : 0, "b" : 1, "c" : 2, "d" : 3, "e" : 4]
print(dic)



// 3) 집합(Set)
// 딕셔너리와 마찮가지로 값의 순서가 없으며, 중복된 값을 저장 할 수 없음 일반적으로 배열에 중복 요소를 제거하기 위해 변환하여 사용 하며 각 요소는 해쉬어블 해야함


var set: Set = [1,1,2,2,3,4,5]
print(set)

// 차이점 배열은 요소가 순서가 있으며 딕셔너리와 집합은 요소의 순서가 없고 각 키값은 해시어블해야 한다는 특징이 있음





/**==================================================================
 [3번 문제]
  - 아래의 personName변수에 들어있는 값을 if let 바인딩으로 언래핑해서 이름을
    출력해 보세요.
 ===================================================================**/

class Person {
    var name: String? = "홍길동"
}

var personName = Person().name


// 옵셔널 바인딩 코드 작성

if let name = personName {
    print(name)
}








/**==================================================================
 [4번 문제]
  - 아래의 a상수의 옵셔널 값을 switch문으로 이용해서 꺼내서 출력해 보세요.
    (힌트. some과, none 그리고, 연관값을 꺼내는 방법을 이용해 보세요.)
 ===================================================================**/


let a: Int? = 7


// (주석 해제하고) 나머지 전부 구현

switch a {
case .some(let a):
    print(a)
case .none:
    print("nil")
}





/**==================================================================
 [5번 문제]
  - 클래스나 구조체에서 initializer(생성자)의 역할이 무엇인가요? 간단하게 서술하세요.
 ===================================================================**/

// 실제 인스턴스를 메모리 영역에 찍는 역할을 하는 메서드 클래스인 경우 큐에, 구조체인 경우 스택에










/**==================================================================
 [6번 문제]
  - 구조체의 멤버와이즈 이니셜라이저(생성자)가 무엇인가요? 개념에 대해 간단하게
    서술하고, (자유롭게) 예제 코드를 만들어 설명해주세요.
    (힌트. Memberwise (멤버에 관한))
 ===================================================================**/

// 구조체에서 기본생성자와 함께 기본적으로 따로 생성자를 정의하지 않을때 같이 제공해주는 생성자이고
// 구조체 내부에 속성을 모두 초기화 할 수 있도록 도와주는 메서드임

struct Human {
    var name = ""
    var age = 0
}

var test = Human(name: "woogie", age: 24) // 멤버 와이즈 생성자로 구조체 인스턴스 생성
print(test)













/**==================================================================
 [7번 문제]
  - 클래스와 구조체의 근본적인 메모리 구조의 차이점에 대해서, 간단하게 설명해주세요.
    (힌트. Heap(힙)과 Stack(스택)을 참고적으로)
 ===================================================================**/

// 클래스는 생성자를 통하여 메인함수에서 인스턴스를 찍어낸다고 할때 데이터영역에서 해당 클래스가 무엇인지 확인하고 1.큐에 빈 공간이 있는지우선 확인 2.빈공간 확인시 인스턴스를 생성하고 해당 주소를 메인 함수에서 찍어낸 변수에 저장 클래스가 값타입인 근본적인 이유
// 구조체는 생성자를 통하여 메인함수에서 인스턴스를 찍어낸다고 할때 데이터영역에서 해당 구조체가 무엇인지 확인하고 1.해당 메인함수 스택에 있는 변수에 인스턴스를 직접 찍어버림 구조체가
// 구조체는 메인함수가 사라지는 순간 값또한 바로 사라져버리는 방면에 클래스는 메모리 관리를 통하여 큐에 있는걸 제거시켜줘야함
// 이말은 즉슨 어떠한 함수안에서 구조체 인스턴스를 변수에 생성했다고 가정했을때 해당 함수가 사라지면 해당 구조체를 가지고 있는 변수도 사라짐










/**==================================================================
 [8번 문제]
  - 클래스(또는 구조체)에서 계산 속성의 의미가 뭔가요?
  - 아래의 Person2 구조체에서 bmi라는 계산 속성을 구현해서, 쉽게 사람의 BMI를 계산하고
    값을 얻을 수 있게 구현해 보세요.
    (읽기/ 쓰기 속성을 모두 구현해 보세요)
 
    BMI지수 = 몸무게 / 키 x 키         (몸무게를 키의 제곱으로 나눈 값이 BMI)
            (kg기준) (키는 미터 기준)
 
 ===================================================================**/

struct Person2 {
    var name: String = "사람"
    var height: Double = 160.0
    var weight: Double = 60.0
    
    //bmi 계산 속성 구현해서 완성
    var bmi: Double {
        get{
            weight / (height * height)
        }
        set{
            weight = newValue
        }
    }
    
}
var p2 = Person2()
print(p2.bmi)

// (계산 속성에 대한) 간단한 서술
// (계산속성의 의미, 역할, 필요한 이유 등을 간단하게)

// 계산 속성은 해당 클래스, 혹은 구조체에서 인스턴스가 생성될때 초기화 하지 않고 기존 속성들을 연산하고 조합하여 특정 값을 만들때 사용한다
// 실질적으로 메서드 형태이며 두함수가 연관된 값을 가지고 특정 동작을 할때 계산 속성으로 정의 할수 있다.
// 계산 속성을 사용하면 메서드를 사용할때 보다 편리하고 가독성이 높게 사용 할 수 있다.







/**==================================================================
 [9번 문제]
  - 클래스(또는 구조체)에서 속성 감시자의 의미가 뭔가요?
  - 아래의 Profile 클래스에서 message의 변수(속성)에 didSet 속성감시자를 구현해보세요.
    (didSet에서 아래의 메세지를 출력해 보세요.)
 
    print("메세지 - \(여기에뭘써야하죠)에서 \(message)로 변경됨")
 
    위의 문장을 복사해서 사용하세요.
 ===================================================================**/


class Profile {
    var message: String = "기본메세지" {
        didSet{
            print("메세지 - \(oldValue)에서 \(message)로 변경됨")
        }
    }   // 속성 감시자 구현
}




var p1 = Profile()

p1.message
p1.message = "행복하다"
p1.message

// 속성 감시자의 의미는 실질적으로 해당 값이 변경되기전 혹은 변경된후에 개발자가
// 재대로 값이 변경되고 있는지를 체크하기 위함이다. 코드가 많을 경우 어려움을 느낄 수 있기 때문에
// 재대로 직접 메모리 상에서 값이 재대로 변경되는지 찍어보기 위한 용도이다.



/**==================================================================
 [10번 문제]
  - 값타입(Value Type)과 참조타입(Reference Type)에 대해 아는대로 서술하고
    차이점에 대해서 설명해 보세요.
 ===================================================================**/


// 1) 값타입(Value Type)
//  값타입은 대표적으로 구조체 즉 Swift의 기본타입들이 있다. 해당 타입들은 main이라는 스택에서 특정 변수에
// 해당 타입에 맞게 값을 대입할때 스택영역에 직접적으로 값을 찍어 넣는다. 해당 스택에 맞는 함수가 종료되면 그와 동시에 값이 사라진다.




// 2) 참조타입(Reference Type)
// 참조 타입에는 대표적으로 클래스가 있으며 해당 스택에서 클래스를 통하여 인스턴스를 생성시 실질적인 인스턴스는 큐에
// 큐에 해당하는 주소값은 해당 클래스를 통하여 인스턴스를 생성하려고한 스택 변수에 저장 된다. 해당 함수가 종료되더라도
// 해당 인스턴스를 담은 변수만 사라질뿐이고 큐에서 인스턴스는 남아있다.







/**==================================================================
 [11번 문제]
  - 객체지향 프로그래밍(OOP)의 4대 특징에 대해 나열하고, 간단하게 서술하세요.
 ===================================================================**/

// 추상화 : 현실세계에 있는 존재하는 모든것에 굴직한 특징을 잡아 컴퓨터 세계에 객체로 만드는 것을 말한다.
// 캡슐화 : 외부에서 함부로 해당 클래스의 접근하지 못하도록 만드는 것을 말한다 (은닉화 개념도 여기에 포함됨)
// 상속 : 부모 클래스를 상속받아 자식클래스에서 재사용이 가능한 형태로 만드는 것을 의미한다.  ex 엔진 -> 자동차 클래스에서 상속
// 다형성 : 대표적으로 부모가 가진 기능을 재정의 하여 자식클래스에서 원하는데로 정의하여 사용 할 수 있게 만드는것이 있다.














/**==================================================================
 [12번 문제]
  - 아래의 코드 예제에서, Bclass는 Aclass를 상속하고 있습니다. Bclass의 저장속성인
    z를 고려해서, Bclass의 지정생성자를 한개이상 구현하고, 상위(Aclass)의 지정생성자
    (init(x: Int, y: Int))를 편의생성자로 재정의 해보세요.
    (자유롭게 구현해보세요.)
 ===================================================================**/


class Aclass {
    var x: Int
    var y: Int
    
    init(x: Int, y: Int) {
        self.x = x
        self.y = y
    }
    
    convenience init() {
        self.init(x: 0, y: 0)
    }
}



// 아래의 주석을 제거하고 코드를 구현

class Bclass: Aclass {

    var z: Int
    
    init(x: Int, y: Int, z: Int) {
        self.z = z
        super.init(x: x, y: y)
    }
    // 이 부분에 지정생성자 및 편의 생성자(상위의 지정생성자를 재정의해서) 구현
    convenience init() {
        self.init(x: 0, y: 0, z:0)
    }

}





/**==================================================================
 [13번 문제]
  - Singleton패턴이 무엇인가요? 아는 대로 간단하게 서술하고, (자유롭게) 간단한 예제 코드를
    작성해 보세요.
 ===================================================================**/


// 공용으로 사용하고 싶은 인스턴스가 있을때 사용













/**==================================================================
 [14번 문제]
  - 클래스의 타입 메서드의 구현에서, static 키워드와 class 키워드의 차이는 뭔가요?
    간단하게 서술하세요.
 ===================================================================**/


// 둘다 메서드 앞에 붙여주면 타입 메서드가되어 해당 인스턴스에서 사용하는 메서드가 아니라 해당 타입에서 사용되게 만들어줌
// class 키워드는 상속이 가능 하며 static은 상속이 불가능함









/**==================================================================
 [15번 문제]
  - mutating키워드가 뭔가요? 언제 사용했었죠? mutating키워드에 대해서 아는 대로
    간단하게 서술해 보세요.
 ===================================================================**/


//












/**==================================================================
 [16번 문제]
  - 아래에서, SomeSuperclass를 상속한 SomeSubclass에서.. 상위 클래스의
    aValue속성을 계산속성으로 자유롭게 재정의 해보세요.
    (계산 속성으로 재정의시 내부 구현은 자유입니다.)
 ===================================================================**/


class SomeSuperclass {
    var aValue = 0
}



class SomeSubclass: SomeSuperclass {

    // 계산속성으로 재정의 구현
    override var aValue: Int{
        get{
            super.aValue + 10
        }
        set{
            super.aValue = newValue
        }
    }

}



var aaa = SomeSubclass()
aaa.aValue






/**>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 수고 하셨습니다. 😄
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>**/
